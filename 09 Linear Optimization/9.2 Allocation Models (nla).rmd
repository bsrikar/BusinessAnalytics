---
title: "9.2 Allocation Models (nonlinear approach)"
author: "Mark Newman"
output:
  html_document: default
editor_options: 
  chunk_output_type: console
---

The intent of this extended example is to look at the difference between the clasic lp formulation and the nonlinear version to see how the different R packages work. To this end the format will be different starting with the result then looking at the 2 different methods. Read this **AFTER** "9.2 Allocation Models".

# Book results

Per page 245 "As shown in Figure 9.6, ... no chairs, 275 desks, and 100 tables... maximum profit contributation is $8,400..."


# LP Formulation

Descision variables

$X = x_{c}, x_{d}, x_{t}$

* (c)hair, (d)esk, (t)able

Objective function

* Maximize: $15x_{c} + 24x_{d} + 18x_{t}$
  
Subject to

* Fabrication: $4x_{c} + 6x_{d} + 2x_{t} <= 1850$
* Assembly: $3x_{c} + 5x_{d} + 7x_{t} <= 2400$
* Shipping: $3x_{c} + 2x_{d} + 4x_{t} <= 1500$
* Demand Potential:
    * $x_{c} <= 360$
    * $x_{d} <= 300$
    * $x_{t} <= 100$

# R translation (linear)

Clear everything
```{r}
rm(list = ls())
options(scipen = 999)
if (!require('lpSolveAPI')) install.packages('lpSolveAPI', quiet=TRUE)
library(lpSolveAPI)
lpm = make.lp(ncol = 3, nrow = 0)
dimnames(lpm)[[2]] = c("xc","xd","xt")
set.objfn(lpm, c(15,24,18))
xxx = lp.control(lpm, sense = "max")
add.constraint(lpm, c(4,6,2), "<=", 1850)
add.constraint(lpm, c(3,5,7), "<=", 2400)
add.constraint(lpm, c(3,2,4), "<=", 1500)
set.bounds(lpm, lower = c(0,0,0), upper = c(360,300,100))
dimnames(lpm)[[1]] = c("Fabrication", "Assembly", "Shipping")
res = solve.lpExtPtr(lpm)
res == 0
get.objective(lpm)
get.variables(lpm)
print.lpExtPtr(lpm)
delete.lp(lpm)
```

* `res == 0` is the status code for _optimal solution found_
* `get.objective(...)` gets the value of the _objective function_
* `get.variables(...)` gets the value of the _descision variables_

# R translation (non-linear)

Clear everything
```{r}
rm(list = ls())
options(scipen = 999)
```

Required packages
```{r}
if (!require('nloptr')) install.packages('nloptr', quiet=TRUE)
library(nloptr)
```

Add objective function
```{r}
eval_f = function(x) {
  
    objective = -1(15*x[1] + 24*x[2] + 18*x[3])
    gradient = c(
      -15,
      -24,
      -18
    )
    
    #return(list(objective = objective, gradient = gradient))
    return(objective)
}
```

* `nloptr` only solves for the minimum. So to maxmize $f(x)$ we just minimize $-f(x)$
* Always calculate the gradent if you can, if not dont worry because a gradent free algorithm (`algorithm="NLOPT_LN_COBYLA"`) is selected
* Gradient is the deritive of the equation with respect to each variable. I.E 3 variables means 3 results.
    * Gradient is also optional.
    * $\frac{\partial}{\partial x_{c}} (15*x_{c} + 24*x_{d} + 18*x_{t}) = 15$
    * $\frac{\partial}{\partial x_{d}} (15*x_{c} + 24*x_{d} + 18*x_{t}) = 24$
    * $\frac{\partial}{\partial x_{t}} (15*x_{c} + 24*x_{d} + 18*x_{t}) = 18$

Add in all constraints
```{r}
eval_g_ineq = function(x) {
  
  conatraint = c(
    4*x[1] + 6*x[2] + 2*x[3] - 1850,
    3*x[1] + 5*x[2] + 7*x[3] - 2400,
    3*x[1] + 2*x[2] + 4*x[3] - 1500
  )
  
  return (conatraint)
}

lb = c(0,0,0)
ub = c(360,300,100)
```

* `nloptr` only allows a function to evaluate the parameters. `eval_g_ineq` is used when the equation can be re-writen as $xxx <= 0$ and `eval_g_eq` is for when it can be re-writen as $xxx = 0$. In this example we only have the 1 form.


Solve
```{r}
sp1 = lb
sp2 = ub
opts = list(algorithm="NLOPT_LN_COBYLA")

res1 = nloptr(x0=sp1, eval_f=eval_f, eval_g_ineq = eval_g_ineq, lb=lb,ub=ub, opts=opts)
res2 = nloptr(x0=sp2, eval_f=eval_f, eval_g_ineq = eval_g_ineq, lb=lb,ub=ub, opts=opts)

print.nloptr(res1)
print.nloptr(res2)
```

* When using a non-linear solver, always do at least 2 starting positions. Upper (`ub`) and lower (`lb`) bounds are usualy good bets.

