---
title: "9.2 Allocation Models (genetic algorithm)"
author: "Mark Newman"
output:
  html_document: default
editor_options: 
  chunk_output_type: console
---

The intent of this extended example is to look at how to solve a clasic lp formulation using a genetic solver to see how the different R packages work. **Please note** genetic algorithms are **ill suited** to solve linear and smooth non-linear problems. They get "close", but not optimal. Their power is getting unstuck from a local min/max to goto a global min/max.

# LP Formulation

Descision variables

$X = x_{c}, x_{d}, x_{t}$

* (c)hair, (d)esk, (t)able

Objective function

* Maximize: $15x_{c} + 24x_{d} + 18x_{t}$
  
Subject to

* Fabrication: $4x_{c} + 6x_{d} + 2x_{t} <= 1850$
* Assembly: $3x_{c} + 5x_{d} + 7x_{t} <= 2400$
* Shipping: $3x_{c} + 2x_{d} + 4x_{t} <= 1500$
* Demand Potential:
    * $x_{c} <= 360$
    * $x_{d} <= 300$
    * $x_{t} <= 100$

# R translation

**Process**

* Clear everything
* Required packages
* Add fitness function
    * `genoud(...)` apperes to only allows for the notion of "fitness" and not constraints. so calculate the `objective`, then exaluate all the `constraints`. if any of the constraints are violated make the objective `0`
        * Objective Max should update the result to a small(`0`) value
    * All constraints should be re-written in the form of $f(x) <= 0$ to make the final update eiser to understand
* Add in the Domain. The first column is the lower bound and the second column is the upper bound.
* Solve
    * When using a genetic algorithm solver, always do at least 2 starting positions. Upper (`Domains[,2]`) and lower (`Domains[,1]`) bounds are usualy good bets.
    * Use `set.seed(...)` to get predictable results when re-running.
    * Use `data.type.int = TRUE` whenever posible else the GA will tend to return a float
    * Use `Domains` but **NOT** `boundary.enforcement=2`. This may seem counter intituive, but if the generation can't "grow" outside the space, it has a hard time aproaching the line.
    * Use `print.level = 0` because `genoud(...)` is _super_ chatty otherwise.
    * `model1$value` is the result of the objective function.
        * $Objective = 8397$
    * `model1$par` are the values of the desision variables that made the `model1$value`
        * $X = 3,273,100$

**R Results**

Make profit of $8,397 by building the below

* 3 chairs
* 273 desks
* 100 tables

**Book results**

Per page 245 "As shown in Figure 9.6, ... no chairs, 275 desks, and 100 tables... maximum profit contributation is $8,400..."

**Code**
```{r results="hold"}
rm(list = ls())
options(scipen = 999)
if (!require('rgenoud')) install.packages('rgenoud', quiet=TRUE)
library(rgenoud)
fn = function(x) {
  
    objective = 15*x[1] + 24*x[2] + 18*x[3]
    constraints = c(
      4*x[1] + 6*x[2] + 2*x[3] - 1850,
      3*x[1] + 5*x[2] + 7*x[3] - 2400,
      3*x[1] + 2*x[2] + 4*x[3] - 1500
    )
    
    if(any(constraints > 0))
      objective = 0
    
    return (objective)
}
Domains = t(matrix(c(0,0,0,360,300,100), nrow = 2, ncol = 3, byrow = TRUE))

sp1 = Domains[,1]
sp2 = Domains[,2]

set.seed(1)
model1 = genoud(fn=fn, nvars=3, max=TRUE, starting.values=sp1, Domains=Domains, print.level = 0, data.type.int = TRUE)
set.seed(1)
model2 = genoud(fn=fn, nvars=3, max=TRUE, starting.values=sp2, Domains=Domains, print.level = 0, data.type.int = TRUE)

model1$value
model2$value
model1$par
model2$par
```

